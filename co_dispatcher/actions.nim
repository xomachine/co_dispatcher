from co_protocol.pipeproto import Task, Answer
from cache import ModuleCache

proc runTask*(cache: ModuleCache, task: Task): Answer
proc prepareTask*(cache: ModuleCache, task: Task): Answer

from co_protocol.signature import checkSignature
from co_protocol.pipeproto import DispatcherAnswerType, SignedRequest, serialize,
                                  deserialize, ReqType
from tables import `[]`
from streams import newFileStream, atEnd, write, readChar, readAll
from detector import feedData, feedAndWait
from osproc import Process, hasData, outputStream, inputStream, terminate,
                   waitForExit
from macros import nnkOfBranch, expectKind, expectMinLen, insert, `[]`, newTree,
                   hint, children, quote, kind, treeRepr, nnkPar
import co_protocol.modproto

macro generalDispatch*(request: SignedRequest, matches: typed): untyped =
  ## Checks `request`'s signature and dispatches it according the `matches`.
  ## The `matches` should follow the pattern:
  ##
  ##.. code-block:: nim
  ##  generalDispatch(request, {
  ##      requestKind1: action1(),
  ##      requestKind2: action2()
  ##    })
  ##
  ## The code generated by macro returns an `Answer`. All invalid requests
  ## (including bad signed or not mentioned in `matches`) will be handled
  ## automatically.
  var caseStmt = quote do:
    case `request`.kind
    else:
      Answer(kind: Error, description: "Unexpected request type!")
  for m in matches.children():
    let match = m[1]
    match.expectKind(nnkPar)
    match.expectMinLen(2)
    let branch = newTree(nnkOfBranch, match[0], match[1])
    caseStmt.insert(1, branch)
  result = quote do:
    if `request`.checkSignature():
      `caseStmt`
    else:
      Answer(kind: NotAuthorized)
  when defined(debug): hint(result.treeRepr)

proc stopTask(task: Process): Answer =
  ## Sends SIGTERM to the process and returns `Done` answer if the task will
  ## quit in time. Otherwise returns `Error` answer.
  const timeout = 5000 # 5 seconds should be enough to cleanup
  task.terminate()
  let exitcode = task.waitForExit(timeout)
  if exitcode == 0:
    Answer(kind: Done)
  else:
    Answer(kind: Error, description: "The module is not finished in time")

proc runTask(cache: ModuleCache, task: Task): Answer =
  ## Passes given `task` to module and handles all communications between
  ## the module and the queue server.
  let executable = cache[task.module].path
  let input = newFileStream(stdin)
  let output = newFileStream(stdout)
  let tmessage: TaskMessage = (action: "run", task: task)
  let jsonmessage = $toJson(tmessage)
  proc checkInput(p: Process) =
    if p.hasData(): # The message from the module pending
      let pout = p.outputStream()
      let msgchar = pout.readChar() # The module sends only one char which
                                    # should be considered as the message
                                    # code
      let answer =
        case msgchar
        of 's': Answer(kind: Done) # The module started successfully,
                                   # so we forwarding that message
        of 'f': p.stopTask() # The module finished successfully and
                             # waits for termination and the queue
                             # server notification
        of 'e': Answer(kind: Error, description: pout.readAll())
          # The module has encountered an error, the error description is
          # placed after error byte. The module will be exited automatically
          # after error.
        else: Answer(kind: Error, description: "Unknown responce from module!")
      answer.serialize(output)
    if not input.atEnd(): # The message from the queue server
      let request = SignedRequest.deserialize(input)
      let answer = request.generalDispatch({
          Remove: p.stopTask(), # The module should be able to handle sigterm
                                # and correctly finish the task.
          Status: Answer(kind: Done) # Just a signature check
        })
      answer.serialize(output)
  executable.feedAndWait(jsonmessage, checkInput)
  let stopreply = Answer(kind: Error,
                         description: "The module has stopped without notice!")
  # After completion of feedAndWait procedure, the module is defenitely
  # stopped. So if the module stop was not expected, the error message should
  # notify the queue server about it. Otherwise the queue server will ignore
  # this message (or stop the dispatcher before the message will be sent.
  stopreply.serialize(output)

proc prepareTask(cache: ModuleCache, task: Task): Answer =
  ## The task preparation is the way to obtain task requirements from
  ## task-related files. It should be done once the task is added to
  ## the queue first time.
  ## The result of task preparation should be the updated task description
  ## structure with correct requirements inside.
  result.kind = Error
  let executable = cache[task.module].path
  let message: TaskMessage = (action: "prepare", task: task)
  let input = $toJson(message)
  let reply = executable.feedData(input)
  if not reply.isNil:
    var answer: TaskMessage
    try:
      fromJson(answer, reply.parseJson())
      result.kind = Prepared
      result.task = answer.task
    except DeserializeError:
      result.description = getCurrentExceptionMsg()
  else:
    result.description = "The module does not replied for request!"
